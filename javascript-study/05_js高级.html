<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS高级</title>
</head>
<body>
<h1>JS高级</h1>
<ul>
    <li>变量提升与函数提升</li>
    <li>执行上下文</li>
    <li>作用域</li>
    <li>闭包</li>
    <li>定时器说明</li>
    <li>WebWorkers_多线程</li>
</ul>

</body>
<script src="js/myModel.js"></script>
<script src="js/myModel2.js"></script>

<script type="text/javascript">
    window.onload = function () {
        console.log('============================变量函数提升开始===================================');
        functionVarUP();
        console.log('============================变量函数提升结束===================================');

        console.log('============================执行上下文开始===================================');
        /**
         * 1. 代码分类(位置)
         *   * 全局代码
         *   * 函数(局部)代码
         * 2. 全局执行上下文  === 全局的代码代码执行流程
         *   * 在执行全局代码前将window确定为全局执行上下文
         *   * 对全局数据进行预处理
         *     * var定义的全局变量==>undefined, 添加为window的属性
         *     * function声明的全局函数==>赋值(fun), 添加为window的方法
         *     * this==>赋值(window)
         *   * 开始执行全局代码
         * 3. 函数执行上下文 === 函数代码的内部执行流程
         *   * 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)
         *   * 对局部数据进行预处理
         *     * 形参变量==>赋值(实参)==>添加为执行上下文的属性
         *     * arguments==>赋值(实参列表), 添加为执行上下文的属性
         *     * var定义的局部变量==>undefined, 添加为执行上下文的属性
         *     * function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
         *     * this==>赋值(调用函数的对象)
         *   * 开始执行函数体代码
         *
         *
         * 执行上下文栈说明:
         *
         * 1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
         * 2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
         * 3. 在函数执行上下文创建后, 将其添加到栈中(压栈)
         * 4. 在当前函数执行完后,将栈顶的对象移除(出栈)
         * 5. 当所有的代码执行完后, 栈中只剩下window
         */
        console.log(a1,window.a1)
        // window.a2() 这里不在全局
        console.log(this)
        var a1 = 3;

        function a2() {
            console.log("a2()")
        }
        console.log(a1)

        console.log('============================执行上下文结束===================================');
        console.log('============================作用域开始===================================');
        /**
         * 作用域==>理解: 大括号内的一片区域, 编写代码时指定的.
         * 2. 分类
         *   * 全局作用域
         *   * 函数作用域
         *   * 没有块作用域(ES6有了)
         * 3. 作用
         *   * 隔离变量，不同作用域下同名变量不会有冲突
         *
         * 作用域与执行上下文区别==>理解: 作用域时代码编写指定, 执行上下文是 执行时根据作用域动态创建的
         * 1. 区别1
         *   * 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
         *   * 全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建
         *   * 函数执行上下文是在调用函数时, 函数体代码执行之前创建
         * 2. 区别2
         *   * 作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化
         *   * 执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放
         * 3. 联系
         *   * 执行上下文(对象)是从属于所在的作用域
         *   * 全局上下文环境==>全局作用域
         *   * 函数上下文环境==>对应的函数使用域
         *
         *
         * 作用域链==>理解: 多个函数嵌套调用, 会按照顺序执行, 递归调用也是一样的不断的压上下文栈
         *   * 多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)
         *   * 查找变量时就是沿着作用域链来查找的
         * 2. 查找一个变量的查找规则
         *   * 在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2
         *   * 在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3
         *   * 再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常
         */

        console.log('============================作用域结束===================================');

        console.log('============================闭包开始===================================');
        /**
         * 1. 如何产生闭包?
         *   * 当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包
         * 2. 闭包到底是什么?
         *   * 使用chrome调试查看: 子函数会携带一个对象 Scopes 里面包含闭包的数据: Closure:0
         *   * 理解一: 闭包是嵌套的内部函数(绝大部分人)      : 如下示例指的是 onclick 函数本身
         *   * 理解二: 包含被引用变量(函数)的对象(极少数人)  : 如下示例指的是 onclick 函数里面的 Scopes对象
         *   * 注意: 闭包存在于嵌套的内部函数中
         * 3. 产生闭包的条件?
         *   * 函数嵌套
         *   * 内部函数引用了外部函数的数据(变量/函数)
         *
         * 闭包的作用
         * 1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
         * 2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)
         *
         * 生命周期
         * 1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
         * 2. 死亡: 在嵌套的内部函数成为垃圾对象时
         *
         *
         * 闭包的应用 : 定义JS模块
         *   * 具有特定功能的js文件
         *   * 将所有的数据和功能都封装在一个函数内部(私有的)
         *   * 只向外暴露一个包信n个方法的对象或函数
         *   * 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
         *
         *
         * 1. 缺点
         *   * 函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
         *   * 容易造成内存泄露
         * 2. 解决
         *   * 能不用闭包就不用
         *   * 及时释放
         */

        console.log("闭包示例")
        const nodeListOf = document.querySelectorAll("li");
        //解决方式2 : 原理,使用了函数自调用,产生了闭包.
        for (var j = 0; j < nodeListOf.length; j++) {
            (function (i){
                nodeListOf[i].onclick = function () {
                    console.log(i)
                };
            })(j)
        }

        console.log("常见闭包1: 将函数参数传递给另一个函数调用")
        function showDelay(msg,time){
            setTimeout(function (){
                console.log(msg)
            },time)
        }
        showDelay("hello",2000)

        console.log("常见闭包2: 将函数作为另一个函数的返回值")
        function fn1() {
            var a = 2;
            function fn2() {
                a++;
                console.log(a)
            }
            return fn2
        }
        const fn2 = fn1();
        fn2()
        fn2()

        console.log("常见闭包3: 闭包应用-模块化")
        var myModel1 = myModel();
        myModel1.doLow()

        myModel2.doUp()


        console.log('============================闭包结束===================================');
        console.log('============================定时器说明开始===================================');
        /**
         * 1. 定时器真是定时执行的吗?
         *   * 定时器并不能保证真正定时执行
         *   * 一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)
         *   * 定时器延迟时间取决于主线程的耗时
         * 2. 定时器回调函数是在分线程执行的吗?
         *   * 在主线程执行的, js是单线程的
         * 3. 定时器是如何实现的?
         *   * 事件循环模型
         *   * 定时器和一些异步任务会被放到两个队列中, 宏队列(定时器/DOM事件/Ajax)和微队列 (MutationObserve/Promise)
         *   * 主线程先执行完 => 遍历执行微队列任务 => 遍历执行宏队列任务
         *
         * 代码的分类:
         *   * 初始化代码
         *   * 回调代码
         *   执行流程: 先执行初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码  => 特定的时刻会执行回调执行代码(异步代码): 处理回调逻辑
         */
        console.log('============================定时器说明结束===================================');

        console.log('============================WebWorkers_多线程开始===================================');
        /**
         * 1. H5规范提供了js分线程的实现, 取名为: Web Workers
         * 2. 相关API
         *   * Worker: 构造函数, 加载分线程执行的js文件
         *   * Worker.prototype.onmessage: 用于接收另一个线程的回调函数
         *   * Worker.prototype.postMessage: 向另一个线程发送消息
         * 3. 不足
         *   * worker内代码不能操作DOM(更新UI)
         *   * 不能跨域加载JS
         *   * 不是每个浏览器都支持这个新特性
         */

        var worker = new Worker("js/worker.js");
        worker.onmessage = function (event) {
            console.log("主线程接收分线程数据: ", event.data)
            console.log('============================WebWorkers_多线程结束===================================');
        }
        worker.postMessage(20)








    };

    //变量函数提升开始
    function functionVarUP() {
        /**
         * 1. 变量声明提升
         *   * 通过var定义(声明)的变量, 在定义语句之前就可以访问到
         *   * 值: undefined
         * 2. 函数声明提升
         *   * 通过function声明的函数, 在之前就可以直接调用
         *   * 值: 函数定义(对象)
         * 3. 问题: 变量提升和函数提升是如何产生的?
         */

        console.log("变量提升")
        console.log("定义在下面的var变量,会先执行赋值到window值为undefined: ", a)
        console.log("function声明的函数,在定义前面可以使用,优先执行了 值: ", aa)
        var a = 2;

        function aa() {
            var c = 2;
            console.log("aa函数")
        }

        if (a) {
            var b = 0;
        }
        console.log("var声明的变量属于全局,在大括号外也能使用: ", b)
        // console.log("如果要局部使用, 可以放方法中不对外暴露: ",c)


        //变量提升的坑, 点击依赖的外部的 i 是错误的. 解决方式: 使用 es6的 let
        const nodeListOf = document.querySelectorAll("li");
        for (var i = 0; i < nodeListOf.length; i++) {
            nodeListOf[i].onclick = function () {
                console.log(i)
            };
        }
        //解决方式2 : 原理,使用了函数自调用,产生了闭包.
        for (var j = 0; j < nodeListOf.length; j++) {
            (function (i){
                nodeListOf[i].onclick = function () {
                    console.log(i)
                };
            })(j)
        }


    }


</script>

</html>
