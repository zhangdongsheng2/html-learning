<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>位置尺寸曲线鼠标等</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body, html {
            margin-left: 15px;
        }

        .box_wrap_3 {
            width: 300px;
            height: 300px;
            background: pink;
        }

        .box_wrap_6 {
            width: 800px;
            height: 200px;
            text-align: center;
            background: red;
            padding-top: 100px;
        }


        .list_ul {
            list-style: inside;
        }

        .box_2 {
            width: 200px;
            height: 200px;
        }

        .box_wrap_2 {
            position: absolute;
            background: pink;
            top: 750px;
            left: 10px;
        }

        .box_2_inner {
            position: absolute;
            background: red;
            top: 90px;
            left: 100px;
        }

        .inner_bounding {
            border: 3px solid;
        }

        .qx_test {
            position: absolute;
            width: 10px;
            top: 2750px;
            height: 10px;
            background: black;
        }

        .dian_box {
            position: absolute;
            border: 1px solid;
        }

    </style>
</head>
<body>
<h1>parentNode</h1>
<div class="box_wrap_3">
    <div id="inner1" class="inner1111">inner1
        <div id="inner2">inner2</div>
    </div>
</div>

<h1>列表删除</h1>
<div class="box_wrap_3">
    <ul class="list_ul">
        <li>xfz <a href="javascript:;">删除</a></li>
        <li>xfz888 <a href="javascript:;">删除</a></li>
        <li>xfz8888 <a href="javascript:;">删除</a></li>
        <li>xfz88888<a href="javascript:;">删除</a></li>
        <li>xfz888888 <a href="javascript:;">删除</a></li>
        <li>xfz9999999 <a href="javascript:;">删除</a></li>
    </ul>
</div>

<h1>获取元素的绝对位置</h1>
<div class="box_2 box_wrap_2 ">
    <div class="box_2 box_2_inner ">inner11</div>
</div>


<h1 style="margin-top: 350px">滚动条滚动的距离</h1>
<div class="box_wrap_3">
    <div class="inner_scroll">inner11</div>
</div>


<h1>getBoundingClientRect</h1>
<div class="box_wrap_3">
    <div class="inner_bounding">inner11</div>
</div>


<h1>mac停靠栏</h1>
<div class="box_wrap_6">
    <img src="img/1.png">
    <img src="img/2.png">
    <img src="img/3.png">
    <img src="img/4.png">
    <img src="img/5.png">
</div>

<h1>鼠标事件绑定</h1>
<div class="box_wrap_3 box_mouse">

</div>

<h1>曲线效果</h1>
<div class="box_wrap_3 box_mouse">
    <div class="qx_test"></div>
</div>


<h1>Canvas动画</h1>
<div class="box_wrap_3">
    <canvas id="canvas-transform-demo" class="canvas-bg" width="300" height="300">
        <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
    </canvas>
</div>


<h1>Canvas动画-阳光下的气泡</h1>
<div class="box_wrap_3">
    <canvas id="canvas-bubbles-in-he-sun" class="canvas-bg" width="300" height="300">
        <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
    </canvas>
</div>

<h1>Canvas动画-气泡效果</h1>
<div class="box_wrap_3">
    <canvas id="canvas-bubbles-effect" class="canvas-bg" width="300" height="300">
        <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
    </canvas>
</div>


</body>
<script type="text/javascript">

    window.onload = function () {
        //================parentNode==================
        let inner2 = document.querySelector("#inner2");
        console.log(inner2.parentNode.id);
        console.log(inner2.parentNode.className);

        //=============列表删除=============
        const listUl = document.querySelectorAll(".list_ul > li > a");
        for (let i = 0; i < listUl.length; i++) {
            listUl[i].onclick = function () {
                //假删除, 数据比较重要
                this.parentNode.style.display = "none";
            };
        }

        //=============获取元素的准确位置==============
        /*
        绝对位置: 到body的距离.
        相对位置: 到视口的而距离
        本身定位胃fixed
            ==> offsetParent:null(不是火狐)
            ==> offsetTop和offsetLeft也是参照body
            ==> offsetParent: body(火狐)
         本身不为fixed
            ==> 父级没有定位: offsetParent: body
            ==> 父级有定位: offsetParent: 父级定位
         */

        const box2Inner = document.querySelector(".box_2_inner");

        console.log(getPointAb(box2Inner))

        function getPointAb(node) {
            let x = 0;
            let y = 0;
            while (node) {
                x += node.offsetLeft;
                y += node.offsetTop;

                node = node.offsetParent;
            }

            return {x: x, y: y}
        }

        //==============滚动条滚动时, 元素滚动的距离================
        const inner_scroll = document.querySelector(".inner_scroll");
        window.onscroll = function () {
            let L = document.documentElement.scrollLeft || document.body.scrollLeft;
            let T = document.documentElement.scrollTop || document.body.scrollTop;
            console.log(L, T);
            console.log(getPointRe(inner_scroll));
        };

        //=============元素相对于窗口位置===============
        console.log(getPointRe(inner_scroll));

        function getPointRe(node) {
            let x = 0;
            let y = 0;
            while (node) {
                x += node.offsetLeft;
                y += node.offsetTop;
                node = node.offsetParent;
            }
            let L = document.documentElement.scrollLeft || document.body.scrollLeft;
            let T = document.documentElement.scrollTop || document.body.scrollTop;
            return {x: x - L, y: y - T}
        }

        //===========getBoundingClientRect=============
        const inner_bounding = document.querySelector(".inner_bounding");

        /*
        getBoundingClientRect : 一个元素四个角的相对位置, 相对窗口
        getBoundingClientRect + 滚动距离 --> 绝对位置
        height, width 盒子尺寸.
        left, top 左上角相对位置.
        right, bottom 右下角位置.
         */
        console.log(inner_bounding.getBoundingClientRect());

        //===========clientW&H-offsetW&H=============
        //clientWidth padding box区域
        console.log(inner_bounding.clientWidth, inner_bounding.clientHeight);
        //offsetWidth  padding box 区域 + border
        console.log(inner_bounding.offsetWidth, inner_bounding.offsetHeight);

        //===================获取可视口尺寸===================
        //视口的大小
        var clientWidth = document.documentElement.clientWidth;
        //跟标签的border-box 边框的盒子大小, 不包括margin
        var offsetWidth = document.documentElement.offsetWidth;
        console.log(clientWidth, offsetWidth);

        //===========mac停靠效果===============
        let macIcon = document.querySelectorAll(".box_wrap_6 > img");
        let box_wrap_6 = document.querySelector(".box_wrap_6");
        box_wrap_6.onmousemove = function (ev) {
            ev = ev || event
            for (let i = 0; i < macIcon.length; i++) {
                const a = macIcon[i].getBoundingClientRect().left + macIcon[i].offsetWidth / 2 - ev.clientX;
                const b = macIcon[i].getBoundingClientRect().top + macIcon[i].offsetHeight / 2 - ev.clientY;
                let c = Math.sqrt(a * a + b * b);
                if (c >= 300) {
                    c = 300;
                }
                macIcon[i].style.width = 128 - c * 0.2 + "px";
            }
        };


        //===========鼠标事件=============
        const boxMouse = document.querySelector(".box_mouse");
        //火狐浏览器
        if (boxMouse.addEventListener) {
            boxMouse.addEventListener("DOMMouseScroll", fn);
        }
        //非火狐浏览器
        boxMouse.onmousewheel = fn;

        function fn(ev) {
            ev = ev || event;
            let dir = "";
            if (ev.detail) {
                console.log("我在滚动,火狐")
                console.log(ev.detail)
                dir = ev.detail < 0 ? "up" : "down";
            }
            if (ev.wheelDelta) {
                console.log("我在滚动")
                console.log(ev.wheelDelta)
                dir = ev.wheelDelta > 0 ? "up" : "down";
            }

            switch (dir) {
                case "up":
                    boxMouse.style.height = boxMouse.offsetHeight - 10 + "px";
                    break;
                case "down":
                    boxMouse.style.height = boxMouse.offsetHeight + 10 + "px";
                    break;
            }


            return false;
        }

        //===========曲线运动=============
        const qxTest = document.querySelector(".qx_test");
        const offsetLeft = qxTest.offsetLeft;
        const offsetTop = qxTest.offsetTop;

        let deg = 0;
        let step = 50;
        setInterval(function () {
            deg++;

            qxTest.style.left = offsetLeft + (deg * Math.PI / 180) * step / 2 + "px";
            qxTest.style.top = offsetTop + Math.sin(deg * Math.PI / 180) * step / 2 + "px";

            const htmlDivElement = document.createElement("div");
            htmlDivElement.classList.add("dian_box");
            htmlDivElement.style.left = qxTest.offsetLeft + "px";
            htmlDivElement.style.top = qxTest.offsetTop + "px";
            document.body.appendChild(htmlDivElement);


        }, 1000 / 60);

        //=================canvas动画====================
        transformDemo();

        //===============阳光下的气泡====================
        bubblesInHeSun();

        //===============气泡效果====================
        bubblesEffect();


    };
    //===============气泡效果====================
    function bubblesEffect() {
        const canvasBase = document.querySelector("#canvas-bubbles-effect");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        //定时添加圆的数据到数组
        const arr = [];
        setInterval(function () {
            const x =  Math.random() * canvasBase.width;
            const r =  Math.random()*6+2;
            const y =  canvasBase.height -r;
            arr.push({
                x: x,
                y: y,
                r: r,
                red: Math.round(Math.random() * 255),
                green: Math.round(Math.random() * 255),
                blue: Math.round(Math.random() * 255),
                alp: 1,
                deg:0,
                startX:x,
                startY:y,
                step:Math.random()*20+3
            });
        }, 50);


        //定时绘制圆到页面, 透明的清理掉, 不透明的慢慢透明
        setInterval(function () {
            for (let i = 0; i < arr.length; i++) {
                arr[i].deg += 5;
                arr[i].x = arr[i].startX + Math.sin(arr[i].deg * Math.PI/180)*arr[i].step*2;
                arr[i].y = arr[i].startY - (arr[i].deg * Math.PI/180)*arr[i].step*2;


                if (arr[i].y <= 30) {
                    arr.splice(i, 1);
                }

            }

            context.clearRect(0, 0, canvasBase.width, canvasBase.height);

            for (let i = 0; i < arr.length; i++) {
                context.save();
                context.fillStyle = "rgba("+arr[i].red+","+arr[i].green+","+arr[i].blue+","+arr[i].alp+")";

                context.beginPath();
                context.arc(arr[i].x, arr[i].y, arr[i].r, 0,2*Math.PI);
                context.fill();
                context.restore();
            }


        }, 1000 / 60);


    }


    //===============阳光下的气泡====================
    function bubblesInHeSun() {
        const canvasBase = document.querySelector("#canvas-bubbles-in-he-sun");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        //定时添加圆的数据到数组
        const arr = [];
        setInterval(function () {
            arr.push({
                x: Math.random() * canvasBase.width,
                y: Math.random() * canvasBase.height,
                r: 10,
                red: Math.round(Math.random() * 255),
                green: Math.round(Math.random() * 255),
                blue: Math.round(Math.random() * 255),
                alp: 1
            });
        }, 50);


        //定时绘制圆到页面, 透明的清理掉, 不透明的慢慢透明
        setInterval(function () {
            for (let i = 0; i < arr.length; i++) {
                if (arr[i].alp <= 0) {
                    arr.splice(i, 1);
                }
                arr[i].r++;
                arr[i].alp-=0.01;
            }

            context.clearRect(0, 0, canvasBase.width, canvasBase.height);

            for (let i = 0; i < arr.length; i++) {
                context.save();
                context.fillStyle = "rgba("+arr[i].red+","+arr[i].green+","+arr[i].blue+","+arr[i].alp+")";

                context.beginPath();
                context.arc(arr[i].x, arr[i].y, arr[i].r, 0,2*Math.PI);
                context.fill();
                context.restore();
            }


        }, 1000 / 60);


    }

    //=================canvas动画====================
    function transformDemo() {
        const canvasBase = document.querySelector("#canvas-transform-demo");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        let transValue = 0;
        setInterval(function () {
            transValue++;
            context.clearRect(0, 0, canvasBase.width, canvasBase.height);
            context.save();
            context.translate(transValue, transValue);
            context.strokeStyle = "black";
            context.beginPath();
            context.rect(0, 0, 100, 100);
            context.stroke();
            context.restore();

            if (transValue >= 300) {
                transValue = 0;
            }
        }, 1000 / 60)
    }

</script>

</html>
