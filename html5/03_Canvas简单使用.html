<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Canvas简单使用</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            margin-left: 15px;
        }

        h1 {
            margin: 15px auto;
        }

        .canvas-bg {
            background: gray;
        }

        #canvas-wh {
            /*width: 500px;*/
            /*height: 300px;*/
        }
    </style>
</head>
<body>
<h1>基本用法-矩形</h1>
只有矩形是原生的cavas图形, 只需要一个api就可以绘制.
<br/>
<canvas id="canvas-base" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>小数问题</h1>
canvas在渲染矩形边框时，边框宽度是平均分在偏移位置的两侧。<br/>
带边框的矩形: 如果是100 = 从99.5绘制到100.5 <br/>
所以: 绘制到 100.5 = 101 像素, 在绘制时带边框的矩形可以减小0.5
<br><br>
<canvas id="canvas-decimal" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>高宽问题</h1>
不能在css中设置画布的高宽, 会导致内容变形<br/>
<br><br>
<canvas id="canvas-wh" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>路径</h1>
<canvas id="canvas-path" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>LineCap</h1>
<canvas id="canvas-cap" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>Save&Restore</h1>
<canvas id="canvas-save-restore" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>签名版案例</h1>
<canvas id="canvas-sign" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>圆</h1>
<canvas id="canvas-circle" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>贝塞尔</h1>
<canvas id="canvas-bessel" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>

<h1>变换</h1>
<canvas id="canvas-transform" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>

<h1>变换-实例</h1>
<canvas id="canvas-transform-demo" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>

<h1>时钟</h1>
<canvas id="canvas-clock" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>

<h1>使用图片</h1>
<canvas id="canvas-image" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>径向渐变</h1>
<canvas id="canvas-radial-gradient" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>

<h1>线性渐变</h1>
<canvas id="canvas-line-gradient" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>飞鸟</h1>
<canvas id="canvas-asuka" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>

<h1>绘制文本</h1>
<canvas id="canvas-text" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>

<h1>像素操作</h1>
<canvas id="canvas-px" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>

<h1>像素操作-getset</h1>
<canvas id="canvas-pxgetset" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>马赛克</h1>
<canvas id="canvas-mosaic" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>全局透明-合成</h1>
<canvas id="canvas-transparent-compose" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


<h1>导出图片-事件</h1>
<canvas id="canvas-ex-le" class="canvas-bg" width="300" height="300">
    <span>您的浏览器不支持画布元素, 请使用谷歌浏览器</span>
</canvas>


</body>
<script type="text/javascript">
    //canvas 基本模板
    function canvasModel() {
        /*
        * 1. 路径容器
        *    每次调用路径api, 都往路径容器中做标记.
        *    调用beginPath 清空路径容器.
        * 2. 样式容器
        *    每次调用样式api时, 都会往样式容器中做标记.
        *    调用save, 样式容器里面的状态入样式栈.
        *    restore时候, 将样式栈的顶状态弹出到容器中.
        * 3. 样式栈
        *    save时容器中的状态入栈, restore时栈中第一个弹出到容器进行覆盖.
        * */
        const canvasBase = document.querySelector("#canvas-");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        context.save();
        //关于样式的设置. save restore 成对出现
        context.beginPath();
        //关于路径
        context.restore(); //green

        context.save();
        //关于样式
        context.beginPath();
        //关于路径
        context.fill();
        context.restore();
    }

    window.onload = function () {
        canvasBaseF();
        canvasDecimalF();
        canvasWH();
        canvasPath();
        canvasLineCap();
        canvasSaveRestore();
        canvasSign();
        canvasCircle();
        canvasBessel();
        canvasTransform();
        canvasTransformDemo();
        canvasClock();
        canvasImage();
        canvasRadialGradient();
        canvasLineGradient();
        canvasAsuka();
        canvasText();
        canvasPx();
        canvasPxGetSet();
        canvasMosaic();
        canvasTransparentCompose();
        canvasExLe();
    }

    //导出图片-事件
    function canvasExLe() {
        const canvasBase = document.querySelector("#canvas-ex-le");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        // 全局透明
        context.fillStyle = "red";
        context.globalAlpha=.5;
        context.beginPath();
        context.fillRect(0, 0, 100, 100);
        context.fill();
        context.beginPath();
        context.arc(200, 200, 50, 0,360*Math.PI/180);
        context.fill();

        // console.log(canvasBase.toDataURL());

        canvasBase.onclick=function (ev){
            console.log("====================");
            ev = ev||event;
            console.log("====================",ev);
            let x = ev.clientX - canvasBase.getBoundingClientRect().left;
            let y = ev.clientY - canvasBase.getBoundingClientRect().top;
            if (context.isPointInPath(x, y)) {
                alert(123);
            }
        }

    }

    //全局透明-合成
    function canvasTransparentCompose() {
        const canvasBase = document.querySelector("#canvas-transparent-compose");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        //全局透明
        // context.fillStyle = "red";
        // context.globalAlpha=.5;
        // context.fillRect(0, 0, 100, 100);
        // context.fillRect(100, 100, 100, 100);

        //图片合成， 只显示交集
        context.fillStyle = "pink";
        context.fillRect(0,150,100,100);
        context.globalCompositeOperation = "destination-atop";
        context.fillStyle = "green";
        context.fillRect(50, 200, 100,100);

    }


    //马赛克
    function canvasMosaic() {
        const canvasBase = document.querySelector("#canvas-mosaic");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        let img = new Image();
        img.src = "img/yuyi.png";
        img.onload=function (){
            context.width = img.width*2;
            context.height = img.height*2;

            context.drawImage(img, 0, 0);
            let oldImagedata = context.getImageData(0, 0, img.width, img.height);
            let newImagedata = context.createImageData(img.width, img.height);
            //马赛克
            /*
            1. 选取一个马赛克矩形
            2. 从马赛克矩形中抽取一个像素点 rgba
            3. 将整个马赛克矩形中的像素点信息统一调成随机的那个
             */

            let size = 5;
            for (let i = 0; i < oldImagedata.width / size; i++) {
                for (let j = 0; j < oldImagedata.height / size; j++) {
                    //(i,j) 每一个马赛克矩形的坐标
                    //0,0  0,1  0,2 ..... width，height

                    //Math.floor(Math.random()*size) 整数随机数
                    //从小方块中随机抽取一个像素点信息
                    let color = getPxInfo(oldImagedata,i*size+Math.floor(Math.random()*size),j*size+Math.floor(Math.random()*size));

                    //将马赛克中所有的点，都设置成随机抽取的那一个
                    for (let k = 0; k < size; k++) {
                        for (let l = 0; l < size; l++) {
                            setPxInfo(newImagedata,i*size+k,j*size+l, color);
                        }
                    }
                }
            }

            context.clearRect(0, 0, canvasBase.width, canvasBase.height);
            context.putImageData(newImagedata, 0, 0);

        }

    }

    //操作像素GetSet
    function canvasPxGetSet() {
        const canvasBase = document.querySelector("#canvas-pxgetset");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        context.save();
        context.fillStyle = "rgba(255,0,0,1)";
        context.beginPath();
        context.fillRect(50, 50, 100, 100);
        context.restore();

        let imgdata = context.getImageData(0, 0, canvasBase.width, canvasBase.height);

        for (let i = 0; i < imgdata.width; i++) {
            setPxInfo(imgdata, 100, i, [255, 0, 0, 255]);
            setPxInfo(imgdata, 20, i, [255, 0, 0, 255]);
            setPxInfo(imgdata, 10, i, [255, 0, 0, 255]);
        }

        context.putImageData(imgdata, 0, 0);

    }
    //获取一个点的像素颜色 的rgba值
    function getPxInfo(imgdata, x, y) {
        let color = [];
        let data = imgdata.data;
        let w = imgdata.width;
        let h = imgdata.height;

        color[0] = data[(y * w + x) * 4];
        color[1] = data[(y * w + x) * 4+1];
        color[2] = data[(y * w + x) * 4+2];
        color[3] = data[(y * w + x) * 4+3];

        return color;
    }
    //获取一个点的像素颜色 的rgba值
    function setPxInfo(imgdata, x, y,color) {
        let data = imgdata.data;
        let w = imgdata.width;
        let h = imgdata.height;

        data[(y * w + x) * 4]=color[0];
        data[(y * w + x) * 4+1]=color[1];
        data[(y * w + x) * 4+2]=color[2];
        data[(y * w + x) * 4+3]=color[3];
    }


    //操作像素
    function canvasPx() {
        const canvasBase = document.querySelector("#canvas-px");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        context.fillStyle = "rgba(255,0,0,1)";
        context.fillRect(0, 0, 100, 100);

        /**
         * ImageData
         * width: 横向上像素点的个数。
         * height: 纵向上像素点的个数。
         * data: 数组： 每一个像素点的rgba信息。
         *
         */
        let imageData = context.getImageData(0, 0, 100, 100);
        for (let i = 0; i < imageData.data.length/4; i++) {
            //rgba 这里修改b 的数值。
            imageData.data[4*i]=255
            imageData.data[4*i+1]=0
            imageData.data[4*i+2]=0
            imageData.data[4*i+3]=125 //a的值是 0-255
        }
        context.putImageData(imageData, 100, 100);


        context.fillStyle = "rgba(255,0,0,0.5)";
        context.fillRect(200, 200, 100, 100);

    }


    //绘制文本
    function canvasText() {
        const canvasBase = document.querySelector("#canvas-text");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        context.fillStyle = "green";
        context.font = "40px sans-serif";
        // context.textAlign="right";
        context.textBaseline="middle";
        context.fillText("Hello",150,100);
        context.strokeText("Hello",150,100);

        //字体测量
        let textMetrics = context.measureText("Hello");
        console.log(textMetrics);

        //字体居中
        context.fillText("Hello",(canvasBase.width - textMetrics.width) /2, canvasBase.height/2);

        //阴影
        context.shadowOffsetX= 20;
        context.shadowOffsetY=20;
        context.shadowBlur = 30;
        context.shadowColor = "yellow";
        context.fillRect(0, 0, 100, 100);
    }


    //飞鸟
    function canvasAsuka() {
        const canvasBase = document.querySelector("#canvas-asuka");
        canvasBase.width = document.documentElement.clientWidth-20;
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        //第几个图片, 绘制的位置
        let flag = 0,value = 0;

        setInterval(function (){
            context.clearRect(0, 0, canvasBase.width, canvasBase.height);
            value+=10;
            flag++;
            if (flag === 9) {
                flag=1;
            }
            if (value > canvasBase.width) {
                value = 0;
            }
            const img = new Image();
            img.src = "img/q_r" + flag + ".jpg";
            img.onload = function () {
                context.drawImage(img, value, 0);
            };
        },100)

    }

    //径向渐变
    function canvasRadialGradient() {
        const canvasBase = document.querySelector("#canvas-radial-gradient");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        let gradient = context.createRadialGradient(150, 150, 50, 150, 150, 100);
        gradient.addColorStop(0, "red");
        gradient.addColorStop(0.5, "yellow");
        gradient.addColorStop(0.7, "pink");
        gradient.addColorStop(1, "green");
        context.fillStyle=gradient;
        context.fillRect(0, 0, 300, 300);
    }

    //线性渐变
    function canvasLineGradient() {
        const canvasBase = document.querySelector("#canvas-line-gradient");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        let gradient = context.createLinearGradient(0, 0, 200, 200);
        gradient.addColorStop(0, "red");
        gradient.addColorStop(0.5, "yellow");
        gradient.addColorStop(0.7, "pink");
        gradient.addColorStop(1, "green");
        context.fillStyle=gradient;
        context.fillRect(0, 0, 300, 300);

    }


    //使用图片
    function canvasImage() {
        const canvasBase = document.querySelector("#canvas-image");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        let img = new Image();
        img.src = "img/yuyi.png"
        img.onload = function () {
            context.scale(.5,.5);
            //使用图片
            context.drawImage(img, 100, 200, img.width, img.height);

            //使用背景
            context.fillStyle = context.createPattern(img, "no-repeat");
            context.fillRect(0, 0, 500,500);
        };

    }

    //时钟
    function canvasClock() {
        const canvasBase = document.querySelector("#canvas-clock");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        setInterval(function () {
            context.clearRect(0, 0, canvasBase.width, canvasBase.height);
            context.save();
            context.lineWidth = 8;
            context.strokeStyle = "black";
            context.lineCap = "round";
            context.translate(150, 150);
            context.scale(.5, .5);
            context.rotate(-90 * Math.PI / 180);
            context.beginPath();

            //外层空心圆盘.
            context.save();
            context.strokeStyle = "#325FA2";
            context.lineWidth = 14;
            context.beginPath();
            context.arc(0, 0, 140, 0, 360 * Math.PI / 180, true);
            context.closePath()
            context.stroke();
            context.restore();

            //时针刻度
            context.save();
            for (let i = 0; i < 12; i++) {
                context.rotate(30 * Math.PI / 180);
                context.beginPath();
                context.moveTo(110, 0);
                context.lineTo(130, 0);
                context.stroke();
            }
            context.restore();

            //分针刻度
            context.save();
            context.lineWidth = 4;
            for (let i = 0; i < 60; i++) {
                context.rotate(6 * Math.PI / 180);
                if ((i + 1) % 5 !== 0) {
                    context.beginPath();
                    context.moveTo(127, 0);
                    context.lineTo(130, 0);
                    context.stroke();
                }
            }
            context.restore();

            //时针, 分针, 秒针, 表座
            let date = new Date();
            let s = date.getSeconds();
            let m = date.getMinutes() + s / 60;
            let h = date.getHours() + m / 60;
            h = h > 12 ? h - 12 : h;

            //时针
            context.save();
            context.lineWidth = 14;
            context.rotate(h * 30 * Math.PI / 180);
            context.beginPath();
            context.moveTo(-10, 0);
            context.lineTo(70, 0);
            context.stroke();
            context.restore();

            //分针
            context.save();
            context.lineWidth = 10;
            context.rotate(m * 6 * Math.PI / 180);
            context.beginPath();
            context.moveTo(-18, 0);
            context.lineTo(92, 0);
            context.stroke();
            context.restore();

            //秒针
            context.save();
            context.lineWidth = 6;
            context.rotate(s * Math.PI / 180);
            context.beginPath();
            context.moveTo(-30, 0);
            context.lineTo(83, 0);
            context.stroke();
            context.beginPath();
            context.arc(0, 0, 10, 0, 360 * Math.PI / 180);
            context.fill();
            context.beginPath();
            context.arc(96, 0, 10, 0, 360 * Math.PI / 180);
            context.stroke();
            context.restore();

            context.restore();
        }, 1000)
    }

    //变换
    function canvasTransformDemo() {
        const canvasBase = document.querySelector("#canvas-transform-demo");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        //旋转角度, 缩放大小,  是放大还是缩小
        let flag = 0, scale = 0, flagScale = 0

        setInterval(function () {
            flag++;
            context.clearRect(0, 0, canvasBase.width, canvasBase.height);
            context.save();
            context.translate(150, 150);
            context.rotate(flag * Math.PI / 180);
            if (scale === 100) {
                flagScale = -1;
            } else if (scale === 0) {
                flagScale = 1;
            }
            scale += flagScale;
            context.scale(scale / 50, scale / 50);
            context.beginPath();
            context.fillRect(-25, -25, 50, 50);
            context.restore();
        }, 10)

    }

    //变换
    function canvasTransform() {
        const canvasBase = document.querySelector("#canvas-transform");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        context.beginPath();
        //移动canvas的原点到某个位置
        context.translate(10, 10);
        context.beginPath();
        context.fillRect(0, 0, 100, 100);
        context.beginPath();

        context.save();
        //旋转的角度, 围绕原点.
        context.translate(150, 150);
        context.rotate(60 * Math.PI / 180)
        context.beginPath();
        context.fillRect(-50, -50, 150, 100);
        context.restore();

        /*
        css 像素是一个抽象单位
            放大: 使画布内css像素的个数变少, 单个css像素所占实际物理尺寸变大.
            缩小: 使画布内css像素个数变多, 单个css像素所占实际物理尺寸变小.
         */
        context.save();
        context.fillStyle = "red";
        context.scale(2, 2);
        context.beginPath();
        context.fillRect(0, 70, 20, 20)
        context.restore();

        //实例: 中间放个方块, 自动放大缩小.
        context.save();
        context.fillStyle = "pink";
        context.translate(150, 150);
        context.beginPath();
        context.fillRect(-25, -25, 50, 50);
        context.restore();

    }


    //贝塞尔曲线
    function canvasBessel() {
        const canvasBase = document.querySelector("#canvas-bessel");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        context.beginPath();
        context.moveTo(50, 50);
        context.lineTo(280, 20);
        context.lineTo(200, 200);
        context.stroke();

        context.beginPath();
        context.moveTo(50, 50);
        //cp1x,cp1y为一个控制点，x,y为结束点。 起点 move
        context.quadraticCurveTo(280, 20, 200, 200);
        context.stroke();

        context.beginPath();
        context.moveTo(50, 50);
        //cp1x,cp1y为一个控制点，cp2x,cp2y为二个控制点, x,y为结束点。 起点 move
        context.bezierCurveTo(280, 20, 0, 280, 300, 300);
        context.stroke();

    }

    //画圆
    function canvasCircle() {
        const canvasBase = document.querySelector("#canvas-circle");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");
        context.beginPath();
        context.moveTo(100, 100);
        context.beginPath();//清除上面的线
        //           x   y   半径 开始角度   结束角度       逆顺时针
        context.arc(100, 100, 50, 0, 360 * Math.PI / 180, true);
        context.closePath();
        context.stroke();

        context.beginPath();
        context.moveTo(50, 50);
        context.lineTo(300, 0);
        context.lineTo(100, 200);
        context.stroke();


        //从 (50,50) (300,0) (200,50) 三个点,
        //根据点1与点2连接的直线，和点2与点3连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径。
        context.beginPath();
        context.moveTo(50, 50);
        //介于两个切线之间的弧/曲线
        //            x   y   x2   y2   半径
        context.arcTo(300, 0, 100, 200, 50);
        context.stroke();

    }

    //签名写字板
    function canvasSign() {
        const canvasBase = document.querySelector("#canvas-sign");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        canvasBase.onmousedown = function (ev) {
            ev = ev || window.event;//防止事件为空
            if (canvasBase.setCapture) {
                canvasBase.setCapture();
            }
            context.beginPath();
            context.moveTo(ev.clientX - canvasBase.getBoundingClientRect().left, ev.clientY - canvasBase.getBoundingClientRect().top)

            document.onmousemove = function (ev) {
                context.save();
                context.strokeStyle = "pink";
                ev = ev || window.event;//防止事件为空
                context.lineTo(ev.clientX - canvasBase.getBoundingClientRect().left, ev.clientY - canvasBase.getBoundingClientRect().top);
                context.stroke();
                context.restore();
            }

            document.onmouseup = function () {
                document.onmousemove = document.onmouseup = null;
                if (document.releaseCapture) {
                    document.releaseCapture();
                }
            };
            return false;
        };
    }


    //Save&Restore 状态的出栈入栈
    function canvasSaveRestore() {
        const canvasBase = document.querySelector("#canvas-save-restore");
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        //相当于是入栈,
        context.save();
        context.fillStyle = "red";
        context.save();
        context.fillStyle = "pink";
        context.save();
        context.fillStyle = "green";
        context.save();

        //开始一条路径
        context.beginPath();
        context.moveTo(100, 100);
        context.lineTo(100, 200);
        context.lineTo(200, 200);
        context.fill();

        context.restore(); //green
        context.restore(); //pink
        context.restore(); //red
        context.fillRect(50, 50, 100, 100);

    }

    //LineCap
    function canvasLineCap() {
        const canvasBase = document.querySelector("#canvas-cap");
        //画矩形
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        context.strokeStyle = "deeppink";
        context.lineWidth = 10;
        context.lineCap = "round";

        context.moveTo(100, 100);
        context.lineTo(100, 200);
        context.stroke();

    }


    //路径
    function canvasPath() {
        const canvasBase = document.querySelector("#canvas-path");
        //画矩形
        if (!canvasBase.getContext) return;
        const context = canvasBase.getContext("2d");

        context.strokeStyle = "deeppink";
        context.fillStyle = "green";
        context.lineWidth = 3;

        context.moveTo(100, 100);
        context.lineTo(100, 200);
        context.lineTo(200, 200);
        context.closePath();
        //绘制线条
        context.stroke();

        //这个方法会自动合并路径, 填充内容.
        context.fill();

        //开始一条路径, 新路径的开始.
        //清空路径容器, 如果不清空会导致覆盖样式.
        context.beginPath();
        context.strokeStyle = "black";
        context.moveTo(200, 200);
        context.lineTo(200, 300);
        // context.lineTo(300, 300);
        context.closePath();

        context.stroke();
    }

    //基本用法矩形
    function canvasBaseF() {
        const canvasBase = document.querySelector("#canvas-base");
        //画矩形
        if (canvasBase.getContext) {
            const context = canvasBase.getContext("2d");
            context.fillRect(0, 0, 100, 100);
            context.fillRect(200, 200, 100, 100);
            context.strokeRect(50, 50, 100, 100);
            context.strokeRect(100, 100, 100, 100);
            context.strokeRect(150, 150, 100, 100);
        }
    }

    //边框小数的注意
    function canvasDecimalF() {
        const canvasBase = document.querySelector("#canvas-decimal");
        //画矩形
        if (!canvasBase.getContext) return
        const context = canvasBase.getContext("2d");
        context.fillStyle = "black";
        context.strokeStyle = "pink";
        context.lineWidth = 25;
        // context.shadowBlur=10;
        // context.shadowColor = "pink";
        // context.fillRect(0, 0, 100, 100);
        context.strokeRect(100, 100, 100, 100);

    }

    //宽高
    function canvasWH() {
        const canvasBase = document.querySelector("#canvas-wh");
        //画矩形
        if (!canvasBase.getContext) return
        const context = canvasBase.getContext("2d");
        context.fillStyle = "black";
        context.strokeStyle = "pink";
        context.shadowColor = "pink";
        context.fillRect(0, 0, 100, 100);

        //rect绘制矩形, 两步
        context.rect(100, 100, 100, 100);
        // context.fill();
        context.stroke();
    }


</script>
</html>
